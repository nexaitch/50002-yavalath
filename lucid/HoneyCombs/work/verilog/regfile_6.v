/*
   This file was generated automatically by Alchitry Labs version 1.2.1.
   Do not edit this file directly. Instead edit the original Lucid source.
   This is a temporary file and any changes made to it will be destroyed.
*/

module regfile_6 (
    input clk,
    input werf,
    input ra2sel,
    input [15:0] write_data,
    input [2:0] ra,
    input [2:0] rb,
    input [2:0] rc,
    output reg [15:0] rd1,
    output reg [15:0] rd2,
    output reg z,
    output reg [3:0] debug_r0,
    output reg [3:0] debug_r1
  );
  
  
  
  wire [16-1:0] M_base_reg_read_data0;
  wire [16-1:0] M_base_reg_read_data1;
  wire [16-1:0] M_base_reg_debug_r0;
  wire [16-1:0] M_base_reg_debug_r1;
  reg [3-1:0] M_base_reg_waddr;
  reg [16-1:0] M_base_reg_write_data;
  reg [1-1:0] M_base_reg_write_en;
  reg [3-1:0] M_base_reg_raddr0;
  reg [3-1:0] M_base_reg_raddr1;
  regfile_base_15 base_reg (
    .clk(clk),
    .waddr(M_base_reg_waddr),
    .write_data(M_base_reg_write_data),
    .write_en(M_base_reg_write_en),
    .raddr0(M_base_reg_raddr0),
    .raddr1(M_base_reg_raddr1),
    .read_data0(M_base_reg_read_data0),
    .read_data1(M_base_reg_read_data1),
    .debug_r0(M_base_reg_debug_r0),
    .debug_r1(M_base_reg_debug_r1)
  );
  
  wire [(2'h3+0)-1:0] M_ra2sel_mux_out;
  reg [(2'h3+0)-1:0] M_ra2sel_mux_inp0;
  reg [(2'h3+0)-1:0] M_ra2sel_mux_inp1;
  
  genvar GEN_ra2sel_mux0;
  generate
  for (GEN_ra2sel_mux0=0;GEN_ra2sel_mux0<2'h3;GEN_ra2sel_mux0=GEN_ra2sel_mux0+1) begin: ra2sel_mux_gen_0
    mux2_12 ra2sel_mux (
      .s0(ra2sel),
      .inp0(M_ra2sel_mux_inp0[GEN_ra2sel_mux0*(1)+(1)-1-:(1)]),
      .inp1(M_ra2sel_mux_inp1[GEN_ra2sel_mux0*(1)+(1)-1-:(1)]),
      .out(M_ra2sel_mux_out[GEN_ra2sel_mux0*(1)+(1)-1-:(1)])
    );
  end
  endgenerate
  
  wire [(5'h10+0)-1:0] M_rd1_select_out;
  reg [(5'h10+0)-1:0] M_rd1_select_inp0;
  reg [(5'h10+0)-1:0] M_rd1_select_inp1;
  reg [(5'h10+0)-1:0] M_rd1_select_s0;
  
  genvar GEN_rd1_select0;
  generate
  for (GEN_rd1_select0=0;GEN_rd1_select0<5'h10;GEN_rd1_select0=GEN_rd1_select0+1) begin: rd1_select_gen_0
    mux2_12 rd1_select (
      .inp0(M_rd1_select_inp0[GEN_rd1_select0*(1)+(1)-1-:(1)]),
      .inp1(M_rd1_select_inp1[GEN_rd1_select0*(1)+(1)-1-:(1)]),
      .s0(M_rd1_select_s0[GEN_rd1_select0*(1)+(1)-1-:(1)]),
      .out(M_rd1_select_out[GEN_rd1_select0*(1)+(1)-1-:(1)])
    );
  end
  endgenerate
  
  wire [(5'h10+0)-1:0] M_rd2_select_out;
  reg [(5'h10+0)-1:0] M_rd2_select_inp0;
  reg [(5'h10+0)-1:0] M_rd2_select_inp1;
  reg [(5'h10+0)-1:0] M_rd2_select_s0;
  
  genvar GEN_rd2_select0;
  generate
  for (GEN_rd2_select0=0;GEN_rd2_select0<5'h10;GEN_rd2_select0=GEN_rd2_select0+1) begin: rd2_select_gen_0
    mux2_12 rd2_select (
      .inp0(M_rd2_select_inp0[GEN_rd2_select0*(1)+(1)-1-:(1)]),
      .inp1(M_rd2_select_inp1[GEN_rd2_select0*(1)+(1)-1-:(1)]),
      .s0(M_rd2_select_s0[GEN_rd2_select0*(1)+(1)-1-:(1)]),
      .out(M_rd2_select_out[GEN_rd2_select0*(1)+(1)-1-:(1)])
    );
  end
  endgenerate
  
  always @* begin
    M_base_reg_write_en = werf;
    M_base_reg_waddr = rc;
    M_base_reg_write_data = write_data;
    M_ra2sel_mux_inp0 = rb;
    M_ra2sel_mux_inp1 = rc;
    M_base_reg_raddr0 = ra;
    M_base_reg_raddr1 = M_ra2sel_mux_out;
    M_rd1_select_s0 = (&(ra));
    M_rd1_select_inp0 = M_base_reg_read_data0;
    M_rd1_select_inp1 = 16'h0000;
    M_rd2_select_s0 = (&(M_ra2sel_mux_out));
    M_rd2_select_inp0 = M_base_reg_read_data1;
    M_rd2_select_inp1 = 16'h0000;
    rd1 = M_rd1_select_out;
    rd2 = M_rd2_select_out;
    z = (~|(M_rd2_select_out));
    debug_r0 = M_base_reg_debug_r0[0+3-:4];
    debug_r1 = M_base_reg_debug_r1[0+3-:4];
  end
endmodule
